\chapter{Cenários de Decisões}
\label{cap-cenarios}

Neste capítulo será apresentado o conceito de Cenários de Decisões, que visa contemplar um dos objetivos principais da presente monografia: Definição de cenários a partir de estudos teóricos para melhorar a interpretação e tomada de decisão sobre métricas estáticas de código-fonte. No Capítulo \ref{cap-metrics} foi apresentada a importância do \emph{design} de software. Além disso, discutimos o papel do Engenheiro de Software no desenvolvimento de códigos com \emph{design} robusto, limpo e seguro, explorando os principais conceitos, problemas, princípios e práticas que este profissional deve conhecer para alcançar esse objetivo. 

Na seção \ref{sec-metrics-security} ainda foram introduzidos temas relacionados ao monitoramento de código-fonte, métricas de \emph{design} de software e métricas de vulnerabilidades. Aferimos que apesar de vários estudos relacionados à utilização de métricas de código-fonte ainda existem muitas dificuldades da adoção prática de métricas de código-fonte em projetos reais de Software. Deve-se enfatizar que métricas não resolvem problemas e sim as pessoas \cite{westfall2005}. Métricas de software atuam como indicadores para prover informação, entendimento, avaliação, controle e predição para que as pessoas possam fazer escolhas e ações. Nesse sentido, no presente capítulo buscamos reduzir a distância entre a medição do código-fonte e tomada de decisões por Engenheiros de Software através da proposta de Cenários de Decisões.

A ideia de definição de cenários para tomada de decisões é advinda do estudo realizado por Almeira \& Miranda (\citeyear{almeida2010}) sobre mapeamento de métricas de código-fonte com os conceitos de Código Limpo. Neste cápitulo, apresentamos os primeiros passos para a extensão desse estudo e propomos o conceito de Cenários de Decisões como uma técnica que pode ser utilizada na abstração de métricas para facilitar o monitoramento de código-fonte. Cenários de Decisões nomeiam e mapeiam estados observáveis através de métricas de código-fonte que indicam a existência de determinada característica dentro do software, classe ou método. Um Cenário de Decisão é composto por:

\begin{itemize}
\item \textbf{Nome}: Identificação única do cenário. Deve ser significativo para prover a compreensão do estado que o cenário representa.

\item \textbf{Métricas Envolvidas}: Identifica as métricas necessárias para a caracterização do cenário, sem definir relações entre essas métricas.

\item \textbf{Nível}: Define o nível de abstração de software que pode ser caracterizada pelo cenário, por exemplo: Projeto; Estrutura de Herança; Classe; Método;

\item \textbf{Descrição}: Discuti os problemas, princípios envolvidos e a caracterização

\item \textbf{Caracterização com Métricas}: Define matematicamente como caracterizar o cenário com as métricas envolvidas. Pode definir a composição destas métricas ou a interpretação conjunta necessária.

\item \textbf{Ações sugeridas}: Propõe um conjunto de ações específicas tais como uma refatoração, a utilização de um padrão de projeto, prática e aplicação de princípios.
\end{itemize}

Cenários de Decisões ainda podem ser classificados de três formas diferentes baseados nas diferentes formas de utilização de métricas para a caracterização do mesmo:

\begin{itemize}
\item \textbf{Monométrico\footnote{Monométrico: de uma só medida}}: Classificação de cenário que pode ser caracterizado por apenas uma métrica, não havendo a necessidade de observação de outras variáveis para que o cenário seja identificado.

\item \textbf{Polimétrico\footnote{Polimétrico: que apresenta ou emprega uma variedade de medidas}}: Classificação de cenário que precisa da interpretação de duas ou mais métricas para ser caracterizado. Cenários polimétricos são menos acoplados a escolha de métricas uma vez que sua identificação depende de mais de uma métrica, podendo ser uma caracterização mais completa de um cenário monométrico. 

\item \textbf{Composto\footnote{Composto: formado de diversas partes}}: Classificação de cenário que é caracterizado a partir de uma métrica composta por outras métricas a partir de fórmulas matemáticas.
\end{itemize}

O objetivo da definição de Cenários é minimizar as principais dificuldades existentes na medição do código-fonte:

\begin{itemize}
\item \textbf{Escolha de Métricas}: Cada cenário é composto por um conjunto de métricas que devem ser utilizadas para aferir a ocorrência do mesmo. Assim, caso se queira observar se um software possui um determinado cenário de vulnerabilidade específica, por exemplo, o Engenheiro de Software ou Gerente devem se preocupar apenas sobre a escolha correta do cenário, abstraindo a escolha de métricas específicas.

\item \textbf{Interpretação de Valores}: A ocorrência de um cenário em algum trecho específico do código deve ser, por si só, o suficiente para o entendimento e avaliação do estado de \emph{design} deste trecho, não havendo a necessidade de ter que se interpretar os valores obtidos. A existência de um cenário ruim específico em um  método deve prover o entendimento necessário para que o Engenheiro de Software realize ações para remoção deste cenário.

\item \textbf{Redundância de Métricas}: Existem muitas métricas na Engenharia de Software que podem ser utilizadas para medir a mesma característica do software tais como tamanho, complexidade e coesão. Compreender cada uma delas e suas intersecções é uma tarefa dispendiosa, dificultando a escolha adequada de métricas que avaliem bem os elementos do software sem redundância de informação. A redundância de métricas não é algo desejado em projetos de software uma vez que a medição é um processo complexo e caro. Cenários idealmente devem ser estabelecidos a partir de estudos e experimentos. Assim, métricas consideradas redundantes podem ser eliminadas a partir da definição de cenários ou podem ser necessárias para a identificação de cenários diferentes para os quais essas métricas agregam alguma informação.

\item \textbf{Interpretações Isoladas}: Podem existir métricas que possam ser utilizadas para a identificação de um cenário específico sem a necessidade de uso de outras métricas. Entretanto, na maioria dos casos uma métrica não provê informação suficiente a ponto de poder ser interpretada isoladamente. Assim, Cenários de Decisões diminuem o risco de interpretações isoladas inadequadas, pois reunem um conjunto de métricas necessários para sua caracterização. Mesmo quando um cenário é definido por uma métrica específica, ele oferece um nível de abstração e interpretação que diminui as possibilidades de erros de interpretação.

\item \textbf{Parâmetros de Comparação}: Os cenários definem uma interpretação a partir de um conjunto de métricas cujos valores podem ser especificados a partir do contexto envolvido, como por exemplo, variar de acordo com a linguagem de programação. Assim, um cenário deve ser adaptável para diferentes contextos devido a importância de se flexibilizar as interpretações de métricas, tema discutido e defendido por Meirelles (\citeyear{meirelles2013metrics}). Sugere-se que a escolha dos parâmetros adequados para caracterização do cenário deve ser feita por especialistas que compreendam as necessidades de seus projetos e as limitações e recursos da linguagem e paradigma de programação utilizados no software. Portanto, a escolha dos valores para caracterização de um cenário é a instanciação deste cenário para um contexto específico. Nesta monografia, além da proposta de cenários, também iremos propor instâncias destes cenários para projetos em C++.
\end{itemize}

Com os Cenários de Decisões introduzimos um novo conceito a ser utilizado na medição de software. Espera-se que o esforço destinado a medição de software em um projeto seja concentrado sobre a instanciação desses cenários, diminuindo-se o esforço necessário para coleta, interpretação e visualização de dados. Entretanto, os benefícios dos Cenários de Decisões são passíveis de experimentação, experimentos esses que estão fora do escopo deste trabalho.

%------------------------------------------------------------------------------%

\section{Definição de Cenários de Decisão para Segurança de Software}
\label{cap-cenarios-sec-definicaocenarios}

A revisão teórica feita nesta monografia encontrada no capítulo \ref{cap-metrics} a respeito de características de bom \emph{design} e vulnerabilidades de software nos permite afirmar que a qualidade do código está diretamente relacionada a vulnerabilidades, visto que um código que possui alta complexidade, baixa modularização, alto acoplamento, entre outras caracteristicas apresentadas na seção \ref{sec-principles-practises} são mais fáceis de inserir vulnerabilidades e dificultam a descoberta de vulnerabilidades já existentes. Na seção (\ref{sec-security-principles}) foi visto também que muitos princípios de segurança de software estão relacionados ao \emph{design} do código. Visto isso, a aplicação de boas práticas de \emph{design} de código se torna essencial para o desenvolvimento de softwares seguros.

Porém, vulnerabilidades de software não ocorrem somente em códigos com mal \emph{design}. Na seção \ref{subsec-vulnerabilities-taxonomy} foi visto que existe uma gama de vulnerabilidades específicas catalogadas pela comunidade, e muitas destas vulnerabilidades foram descobertas e reportadas por grandes empresas de softwares renomados no mercado, que são bem maduras em relação a qualidade de seus produtos. Foi visto também que muitas das vulnerabilidades de software que são identificadas por ferramentas de análise estática seção \ref{subsec-security-metrics} são vulnerabilidades específicas de uso de códigos, funções ou práticas consideradas perigosas para segurança da aplicação. Tais vulnerabilidades podem ser encontradas no código-fonte indepentente da aplicação de boas práticas de \emph{design}, pois são difíceis de identificar e necessitam do conhecimento mais aprofundado do Engenheiro de Software para que este saiba se está inserindo ou não uma vulnerabilidade no código.

Dessa forma, para o contexto de segurança do software, podemos definir dois tipos de cenários de decisão:

\begin{itemize}
\item \textbf{Cenários de Decisão para Caracterização da Qualidade de Código}: Estes cenários buscam identificar caracteristicas de software relacionadas a qualidade e \emph{design} de código que podem influenciar em sua segurança, como complexidade, acoplamento, entre outros.

\item \textbf{Cenários de Decisão para Caracterização de Vulnerabilidades Específicas de Código}: Estes cenários buscam identificar vulnerabilidades de software que podem ser encontradas em código-fonte indepente que este esteja em um bom nível de qualidade e \emph{design}. São cenários relacionados mais a erros que podem ser cometidos pelos desenvolvedores no momento da implementação;
\end{itemize}


O estudo sobre vulnerabilidades de software nos mostrou que grande parte das vulnerabilidades são encontradas na linguagem de programação C/C++. Além disso, existem uma quantidade expressiva de projetos livres desenvolvidos em C++, que incluem grandes projetos renomados como Chrome, Firefox, MySQL e OpenOffice. Vale ressaltar também que ambas as ferramentas que utilizaremos para demonstrar o uso dos cenários já suportam a coleta da maior parte das métricas introduzidas no Capítulo \ref{cap-metrics} para C++.

Dessa forma, decidimos por usar a linguagem C++ como base para instanciação dos cenários propostos a seguir. Como se trata de uma linguagem orientada a objetos, permitirá aplicarmos tanto os conceitos estudados a respeito de \emph{design} de código quanto os conceitos estudados a respeito de vulnerabilidades específicas.

\subsection{Cenários de Decisão para Caracterização da Qualidade do Código }
\label{cenarios-design}

A seguir serão apresentados instâncias de cenários de decisões que visam identificar características de qualidade de código que impactam na segurança. Os cenários a seguir podem ser aplicados a programas que utilizam o paradigma OO, porém, os valores utilizados para as métricas que compõe os cenários foram definidos para projetos C++. Tais valores foram retirados do estudo de Meirelles (\citeyear{meirelles2013metrics}). Nesta seção propomos quatro Cenários de Decisões. 

\subsubsection{Alta Superfície de Ataque a Atributos Internos}
%-------------------------------------------------------------------------------

Este cenário busca identificar a violação do princípio de \emph{design} de segurança Redução da Superfície de Ataque (Seção \ref{sec-security-principles}) em relação aos atributos de um objeto. 
%
Este princípio se baseia fundamentalmente na redução da exposição das estruturas do sistema em relação a interações externas. Em termos de \emph{design}, diminuição do acesso as informações internas da classe podem ser obtidos a partir de um maior grau de encapsulamento das estruturas que compõem esta classe. 
%
Em termos de métricas de código-fonte, este cenário busca medir o tamanho da superfície de ataque aos atributos de uma classe. Estão inclusos nesse cenário classes ou módulos que tenham um alto valor de quantidade de atributos públicos. 

%

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Alta Superfície de Ataque a Atributos Internos
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: NPA (Número de Atributos Públicos), NOA (Número de Atributos);
\item \textbf{Nível}: Classe;
\item \textbf{Descrição}: Esse cenário busca identificar classes que possuem muita exposição devido ao alto número de atributos públicos, violando o princípio de \emph{design} seguro Redução de Superfície de Ataque.
\item \textbf{Caracterização com Métricas}: NPA/NOA > value
	\begin{itemize}
	\item Caracteriza o tamanho da superfície de ataque a atributos em percentagem. O cenário existe quando o valor desta métrica composta está acima do valor (referência) estipulado. Para projetos em C++, value pode ser 0.2
	\end{itemize}
\item \textbf{Ações sugeridas}:
	\begin{itemize}
	\item \textbf{Refatorações aplicáveis:} - \emph{Encapsulate Field}\footnote{\url{http://refactoring.com/catalog/encapsulateField.html}}.
	\item \textbf{Princípios aplicáveis à classe} - Princípio e Redução de Superfície de Ataque; Princípio de Encapsulamento;
	\end{itemize}
\end{itemize}

\subsubsection{Alta Superfície de Ataque Operacional}
%-------------------------------------------------------------------------------

Este cenário busca identificar a violação do princípio de \emph{design} de segurança Redução da Superfície de Ataque (Seção \ref{sec-security-principles}) em relação aos métodos de uma classe. Este princípio se baseia fundamentalmente na redução da exposição das estruturas do sistema em relação as manipulações e operações realizadas pelos métodos da classe. Em termos de \emph{design}, quanto maior a quantidade de métodos públicos, maior a quantidade de interações possíveis com um objeto o que dificulta a aplicação do princípio \emph{Mediate Completely} (Seção \ref{sec-security-principles}) e aumenta a vulnerabilidade das operações. Além disso, a dependência de parâmetros externos para realização de operações internas pode expor maiores detalhes dos mecanismos e algoritmos das classes de um projeto, sendo resultado do baixo grau de encapsulamento das operações, além de aumentar riscos de ataques e dificuldades de correção de problemas de segurança. 

Em termos de métricas de código-fonte, este cenário busca medir o tamanho da superfície de ataque através de operações acessíveis de uma classe e os parâmetros necessários para sua realização. Estão inclusos nesse cenário classes ou módulos que tenham um alto valor de quantidade de métodos públicos e que tenham grande quantidade de parâmetros. 

%

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Alta Superfície de Ataque Operacional
\item \textbf{Classificação}: Polimétrico;
\item \textbf{Métricas Envolvidas}: NPM (Número de Métodos Públicos), ANPM (Média de Parâmetros por Método); 
\item \textbf{Nível}: Classe;
\item \textbf{Descrição}: Esse cenário busca identificar classes que devem receber maior atenção em relação à aplicação do princípio \emph{Mediate Completely} devido à grande exposição da classe em termos operacionais. Este cenário indica que a aplicação do princípio de \emph{design} seguro Redução de Superfície de Ataque pode melhorar o \emph{design} da classe uma vez que as definições e abstrações de seus métodos são reestruturadas.
\item \textbf{Caracterização com Métricas}: NPM > npm\_value || ANPM > anpm\_value
	\begin{itemize}
	\item \textbf{NPM} - Caracteriza a quantidade de interações possíveis para as quais o princípio \emph{Mediate Completely} deve ser aplicado. Para projetos em C++, o valor de npm\_value pode ser 10;
	\item \textbf{ANPM} - Caracteriza a quantidade de informações que poderiam ser verificadas para evitar ataques externos. Para projetos em C++, o valor de anpm\_value pode ser 3; 
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Refatorações aplicáveis aos métodos da classe} - \emph{Hide Method}\footnote{\url{http://refactoring.com/catalog/hideMethod.html}}; \emph{Remove Parameter}\footnote{\url{http://refactoring.com/catalog/removeParameter.html}};
	\item \textbf{Princípios aplicáveis à classe} - Princípio e Redução de Superfície de Ataque; Princípio de Encapsulamento; Princípios de Distribuição de Responsabilidades GRASP \cite{larman2007};
	\item \textbf{Padrões aplicáveis no projeto para reduzir a ocorrência deste cenário} - Padrão \emph{Facade}\footnote{\url{http://sourcemaking.com/design_patterns/facade}};
	\end{itemize}
\end{itemize}

\subsubsection{Ponto Crítico de Falha}
%-------------------------------------------------------------------------------

Este cenário busca identificar a ocorrência de classes ou módulos que concentram muitas responsabilidades das quais muitas outras classes dependem. Este cenário é problemático uma vez que a classe das quais muitas outras classes dependem, em caso de falhas e exploração de vulnerabilidades tendem a afetar muitas outras estruturas do projeto. Além disso, a alta concentração de dependências em uma classe pode ser devido a inadequada distribuição de responsabilidades entre os módulos que compõem o projeto.

Em termos de métricas de código-fonte, este cenário é caracterizado a partir da medição da quatindade de classes que dependem da classe em análise. Esta dependência deve ser considerada em termos de acesso à métodos, acesso à atributos e herança. 

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Ponto Crítico de Falha
\item \textbf{Classificação}: Composto
\item \textbf{Métricas Envolvidas}: ACC (Conexões Aferentes por Classe), NOC (Número de Filhos)
\item \textbf{Nível}: Classe;
\item \textbf{Descrição}: Esse cenário busca identificar classes que potencialmente são pontos críticos do projeto de software. Classes que são caracterizadas com este cenário devem ser cuidadosamente repensadas em termos de responsabilidades para não ser permanecerem sendo potenciais pontos críticos do projetos, uma vez que falhas e exploração de vulnerabilidades podem comprometer toda a estrutura acoplada a ela.
\item \textbf{Caracterização com Métricas}: ACC + NOC > value
	\begin{itemize}
	\item As duas métricas são utilizadas para Caracterizar a quantidade de classes acopladas à classe em análise, tanto em termos de acesso à métodos e atributos quanto em termos de herança. Este cenário existe quando o valor calculado através desta composição é maior do que estipulado. Para projetos em C++, o value pode ser 5.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Refatorações aplicáveis aos métodos da classe} - \emph{Extract Class}\footnote{\url{http://refactoring.com/catalog/extractClass.html}}, \emph{Move Method}\footnote{\url{http://refactoring.com/catalog/moveMethod.html}}, \emph{Push Down Method}\footnote{\url{http://refactoring.com/catalog/pushDownMethod.html}};
	\item \textbf{Princípios aplicáveis à classe} - Princípios de bom \emph{design}: Modularização, Baixo Acoplamento; Princípio de Encapsulamento; Princípios de Distribuição de Responsabilidades GRASP \cite{larman2007};
	\end{itemize}
\end{itemize}

%MUDAR NOME DESTE CENÀRIO

%http://www.mccabe.com/pdf/More%20Complex%20Equals%20Less%20Secure-McCabe.pdf

%https://www.schneier.com/books.html
%https://www.schneier.com/cryptography.html

\subsubsection{Risco Elevado de Segurança}
%-------------------------------------------------------------------------------

Este cenário busca identificar métodos que, devido sua estrutura interna, aumentam os riscos relacionados à segurança, principalmente por dificultarem a realização de testes, a busca de \emph{bugs} existentes e a compreensão do sofware. Em outras palavras, quanto maior a complexidade de um método, mais complexas são suas interações, verificações e mecanismos de segurança. Além disso, o aumento da complexidade tem como consequência a dificuldade de se entender o módulo em análise. Assim, quanto mais complexo um método ou classe, menos pessoas vão compreendê-los completamente, reduzindo as chances dos envolvidos no projeto encontrarem inconformidades e vulnerabilidades.

%

O problema com a complexidade de módulos do software está diretamente relacionado ao princípio de \emph{design} seguro \emph{Economy of mechanism} e ao princípio Simplicidade de bom \emph{design}. Saltzer \& Schroeder (\citeyear{schroeder1975}) afirmam que esses dois princípios são muito importantes pois, erros ou falhas que resultam em vulnerabilidades e acessos não desejados normalmente não são notados durante o uso normal. Portanto, técnicas como inspenção de código e outras são necessárias para assegurar os menamismos de proteção necessários. Assim, para que tais técnicas possam ser utilizadas, um \emph{design} simples e pequeno é essencial.

%

Em termos de métricas de código-fonte, este cenário busca medir a complexidade dos métodos das classes do projeto de software. Idealmente, este cenário poderia ser caracterizado à nível de método, porém, optou-se por manter a nível de classe. Estão inclusos nesse cenário classes com métodos com alta complexidade. 

%

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Risco Elevado de Segurança
\item \textbf{Classificação}: Polimétrico;
\item \textbf{Métricas Envolvidas}: ACCM (Média de Complexidade Ciclomática por Método), MLOC (Média de Número de Linhas de Código por Método);
\item \textbf{Nível}: Classe;
\item \textbf{Descrição}: Esse cenário busca identificar métodos que aumentam o risco de problemas de segurança e \emph{bugs} no código-fonte devido sua complexidade e difícil manutenção.
\item \textbf{Caracterização com Métricas}: ACCM > accm\_value || MLOC > mloc\_value
	\begin{itemize}
	\item \textbf{ACCM} - Caracteriza a complexidade lógica do método, além de medir o mínimo de esforço de testes necessários para o método e o nível de dificuldade para compreensão completa do método. Para projetos em C++, accm\_value pode ser 4;
	\item \textbf{MLOC} - Caracteriza a quantidade de linhas de código dentro de um método, sendo que quanto maior a quantidade de linhas em um método, mais difícil é sua compreensão e inspeção. Para projetos em C++, mloc\_value pode ser 10;
	\end{itemize}
\item \textbf{Ações sugeridas}:
	\begin{itemize}
	\item \textbf{Refatorações aplicáveis:} - \emph{Extract Method}\footnote{\url{http://refactoring.com/catalog/extractMethod.html}},  \emph{Extract Surrounding Method}\footnote{\url{http://refactoring.com/catalog/extractSurroundingMethod.html}}, \emph{Replace Conditional with Polymorphism}\footnote{\url{http://refactoring.com/catalog/eplaceConditionalWithPolymorphism.html}}, \emph{Replace Nested Conditional with Guard Clauses}\footnote{\url{http://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html.html}}, \emph{Substitute Algorithm}\footnote{\url{http://refactoring.com/catalog/substituteAlgorithm.html}}.
	\item \textbf{Princípios aplicáveis ao método} - Princípio de Economia de Mecanismos; Princípio da Simplicidade ou KISS;
	\end{itemize}
\end{itemize}




\subsection{Cenários de Decisão para Caracterização de Vulnerabilidades Específicas de Código}
\label{cenarios-vulnerabilidades}

A seguir serão apresentados instâncias de cenários de decisão que buscam identificar vulnerabilidades específicas de código. Observamos que instâncias desse tipo de cenário são particulares para cada linguagem de programação ou contexo, pois cada tecnologia envolvida na criação de software possui suas particularidades e com elas, vulnerabilidades específicas. Nesse sentido, como dito no início desse capítulo, iremos abordar apenas vulnerabilidades presentes na linguagem C++, tornando os cenários a seguir aplicáveis apenas nesse contexto.

Com o estudo sobre as \emph{CWE's}, percebemos que vulnerabilidades específicas já descrevem um cenário específico pois cada vulnerabilidade caracteriza um problema e um estado do código fonte. Porém, vimos com o estudo das taxonomias que algumas vulnerabilidades estão relacionadas à um problema mais geral. Dessa forma, os cenários propostos a seguir buscam agrupar algumas vulnerabilidades para descrever uma estado de código de maneira mais alto nível.

Em relação aos valores de métricas destes cenários, como cada métrica conta quantas ocorrencias daquela vulnerabilidade ocorre no código, basta então apenas uma ocorrência para que o código se torne vulnerável. Porém, sabemos que até mesmo grandes software estão em produção e possuem suas vulnerabilidades, deixando a idéia de que possa existir uma quantidade "aceitável" de determinada vulnerabilidade. Mas isso cabe a um estudo a parte definir esse valor. Nesta monografia, iremos considerar que vulnerabilidades não podem existir, e devem ser combatidas a todo momento.

Feitas essas observações, definimos 4 cenários nessa seção.


\subsubsection{Uso de variáveis não inicializadas}
%-------------------------------------------------------------------------------

Este cenário busca identificar o uso de variáveis não inicializadas. Este cenário também é definido pela CWE-457 \footnote{http://cwe.mitre.org/data/definitions/457.html}.
%
A declaração de variáveis em algumas linguagens, como C, Perl e PHP, não as pŕe-inicializam com valores padrão. Com isso, variáveis que são criadas na pilha de memória podem conter em seus valores lixo ou até comandos, bem como valores de outras funções e variáveis que também utilizaram da mesma área de memória em outro momento de execução da aplicação.
%
Essa situação é perigosa, pois tanto a aplicação pode apresentar resultados inesperados como também um atacante pode visualizar informações contidas nessa variável que ele não estaria autorizado a ver. 

Muitas vezes podem ocorrer de existir uma estrutura de controle de fluxo de execução de código (como \emph{if else} e \emph{switch case}) que definem a situação em que a variável irá ser inicializada e, ao sair dessa estrutura de controle de fluxo, a variável é finalmente utilizada. Nessa situação, pode ocorrer da aplicação não passar pelo fluxo que inicializa a variável. Dessa forma, ao sair do fluxo, o programa irá usar a variável que não foi inicializada.

Em termos de métricas de código-fonte, este cenário busca medir ocorrências do uso de variáveis não inicializadas. A métrica UAV (\emph{Uninitialized Argument Value}) busca medir argumentos passado como parâmetros de chamada de funções que não foram inicializados. A métrica ROGU (\emph{Result of operation is garbage or undefined}) busca verificar situações onde usamos variáveis não inicializadas em operações lógicas. A métrica AUV (\emph{Assinged Value is garbage or undefined}) busca verificar situações que uma variável recebe o valor de outra variável que pode não ter sido inicializada. Essas três métricas podem ser utilizadas em conjunto, e a ocorrência de qualquer uma delas podem indicar este cenário no cógido fonte.

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Uso de Variáveis não Inicializadas
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: UAV (\emph{Uninitialized Argument Value}), ROGU (\emph{Result of operation is garbage or undefined}), AUV (\emph{Assinged Value is garbage or undefined});
\item \textbf{Nível}: Arquivo;
\item \textbf{Descrição}: Este cenário busca identificar o uso de variáveis não inicializadas, pois isso pode causar desde falhas na aplicação quanto acesso a informação não autorizado.
\item \textbf{Caracterização com Métricas}: AUV + UAV + ROGU >= 1
	\begin{itemize}
	\item Este cenário ocorre quando qualquer uma dessas métricas é maior ou igual a um, caracterizando a ocorrência de pelo menos uma vulnerabilidade relacionada ao conceito do cenário.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Princípios aplicáveis} - \emph{Fail Securery} criando verificações para que não haja erros nem quebra da aplicação por utilizar uma variável não inicializada .
	\item \textbf{Refatorações}: Criar mecanismos para garantir que a variável será inicializada antes de ser usada.
	\end{itemize}
\end{itemize}


\subsubsection{Alta possibilidade de Falha por mau uso de ponteiros}
%-------------------------------------------------------------------------------
Este cenário busca identificar possíveis locais no código fonte em que é feito o mau uso de ponteiros, e que consequentimente podem gerar falhas na aplicação. 

Nos fóruns de dúvidas relacionados a computação e programação, é muito comum identificar relatos de erros de várias pessoas relacionado a falhas de ponteiros que geram o famoso \emph{"segmentation fault"}. Ponteiros, se não utilizados corretamente, podem gerar falhas e são muito difíceis de se identificar. Além disso, existem diferentes situações em que o desenvolvedor pode estar gerando uma falha por mau uso de ponteiros.

Em termos de métricas de código-fonte, este cenário é composto pelas métricas:
\begin{itemize}
	\item \textbf{DNP (\emph{Dereference of null pointer})}
	\item \textbf{DF (\emph{Double free})}
	\item \textbf{AUF (\emph{Use After free})}
	\item \textbf{DUPV (\emph{Dereference of undefined pointer value})}
	\item \textbf{BD (\emph{Bad deallocator})}
\end{itemize}

Todas essas métricas podem identificar possíveis falhas na aplicação. Este cenário pode ser muito útil para solucionar falhas na aplicação cujo não se sabe a causa.

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: Alta possibilidade de Falha por mau uso de ponteiros
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: DNP (\emph{Dereference of null pointer}); DF (\emph{Double free}); AUF (\emph{Use After free}); DUPV (\emph{Dereference of undefined pointer value}); BD (\emph{Bad deallocator});
\item \textbf{Nível}: Arquivo;
\item \textbf{Descrição}: Este cenário busca identificar o uso de ponteiros de maneira não segura, que podem gerar falha na aplicação.
\item \textbf{Caracterização com Métricas}: NP + DF + AUF + DUPV + BD >=1
	\begin{itemize}
	\item Este cenário ocorre quando há a ocorrência de pelo menos uma dessas vulnerabilidade.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Refatorações}: Para cada métrica, deve se tomar uma ação específica para resolve-la. Então, caso ocorra este cenário, devemos observar qual das vulnerabilidades ocorreu trabalhar para reduzir o valor dessa métrica. Por exemplo, se a métrica encontrada for a DNP, sabemos que existe um ponteiro nulo que está sendo desreferenciado, então deve-se tomar providências, de acordo com cada lógica de programa para que isso não aconteça.
		\begin{itemize}
			\item DNP
		\end{itemize}
	\end{itemize}
\end{itemize}


\subsubsection{Buffer Overflow}
%-------------------------------------------------------------------------------

Este cenário busca no código fonte situações que podem gerar a vulnerabilidade de \emph{Buffer Overflow}. Como já mencionado na sessão \ref{sec-metrics-security}, o \emph{Buffer Overflow} é um caso comum de violação da segurança a memória, e ocorre normalmente quando escrevemos dados cujo tamanho  ultrapasse o tamanho do \emph{buffer} definido para ele. Essa situação pode gerar  mau funcionamento do sistema, pois a informação que estourou o \emph{buffer} pode corromper outras informações ou processos que tiveram sua região de memória invadida; como também pode ser usado para injetar códigos malicioso e alterar o fluxo de execução da aplicação.

Em termos de métricas de código fonte, este cenário é composto pelas métricas FGBO (\emph{Potential buffer overflow in call to "gets"}) e pela métrica ASOM (\emph{Allocator sizeof operand mismatch}). A métrica FGBO identifica a utilização da função \emph{"gets"} na linguagem C/C++. Essa função não garante garante que o tamanho da variável de entrada será do tamanho da variável a ser atribuída, se tornando um risco a ser explorado pelos atacantes. A métrica ASOM identifica situações no código em que é passado o operador inadequando no momento que se aloca memória para uma variável. Isso acontece, por exemplo na linguagem C, quando declaramos um ponteiro do tipo inteiro e no momento do alocação de memória é passado um tamanho refente a uma variável do tipo \emph{char}. Logo, o espaço alocado não corresponde ao tamanho do dado que é esperado receber, podendo causar o estouro de \emph{buffer}.

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: \emph{Buffer Overflow}
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: FGBO (\emph{Potential buffer overflow in call to \"gets\"}) e ASOM (\emph{Allocator sizeof operand mismatch})
\item \textbf{Nível}: Arquivo;
\item \textbf{Descrição}: Este cenário busca identificar situações no código fonte que podem gerar a vulnerabilidade de \emph{Buffer Overflow} (Estouro de memória);
\item \textbf{Caracterização com Métricas}: ASOM + FGBO >=1
	\begin{itemize}
	\item Este cenários ocorre quando pelo menos uma dessas vulnerabilidades ocorrem no código.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Substituir chamadas para a função \emph{"gets"}} - a função \emph{"fgets()"} pode ser utilizada no lugar da função  \emph{"gets"}, pois aquela possui um parâmetro em sua chamada que indica o tamanho máximo do \emph{buffer}.  
	\item \textbf{Fazer \emph{match} dos operadores de alocação de memória} - Refator os trechos de cógido atribuindo o operador correto para a alocação de memória; 
	\end{itemize}
\end{itemize}

\subsubsection{Confidencialidade Ameaçada}
%-------------------------------------------------------------------------------

Este cenário busca identificar situações no código fonte onde informações podem ser expostas sem a devida permissão, impactando diretamente em um dos principais aspectos quando falamos de segurança de software: a confidencialidade dos dados.

Um código seguro não pode dar brecha para que o atacante ou qualquer outro usuário possa ver informações que não eram para serem vistas. Alguns erros na codificação, como por exemplo, acessar uma posição de uma \emph{array} fora de seu intervalo, podem acabar mostrando informações de outras regiões de memória, podendo ser essa inforamção crítica ou não para a segurança do sistema.

Em termos de métricas de código fonte, as métricas OBAA (\emph{Out-of-bound array access}) e DUPV (\emph{Dereference of undefined pointer value}) buscam identificar situações de código fonte em que podem ser expostas informações não autorizadas pelo sistema. A métrica OBAA identifica justamente o acesso de indices que não pertencem ao \emph{array}, podendo assim vazar a informação contida na região de memória adjacente a região do \emph{array}. A métrica DUPV identifica situações onde um ponteiro indefinido é desreferenciado, ou seja, quando é lido o valor de um ponteiro que está indefinido. Dessa forma, ele pode estar apontando para uma posição de memória a qual não sabemos, e , consequentemente, vazando alguma informação não autorizada. 

Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: \emph{Confidencialidade Ameaçada}
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: OBAA (\emph{Out-of-bound array access}) e DUPV (\emph{Dereference of undefined pointer value}) 
\item \textbf{Nível}: Arquivo;
\item \textbf{Descrição}: Este cenário busca identificar trechos de código fonte que podem fornecer informações não autorizadas, impactando na confidencialidade do sistema. O acesso a informação não autorizada se dá pela leitura de regiões de memória que não estão no contexto da variável em questão.
\item \textbf{Caracterização com Métricas}: OBAA + DUPV >=1
	\begin{itemize}
	\item Este cenário ocorre quando pelo menos uma dessas vulnerabilidades é encontrada.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Especificar e verificar o range o \emph{array} antes de acessa-lo} - identificar o trecho de código que métrica OBAA aponta e criar mecanismos que garantem o limite do índice de acesso do array, dessa forma iremos garantir que somente a região de memória pertencente ao \emph{array} é acessada e lida.  
	\item \textbf{Garantir que o ponteiro não seja indefinido antes de desreferencia-lo} - Identificar locais em que ponteiros indefinidos são desreferenciados e garantir que eles tenham um valor no momento da leitura.  
	 
	\end{itemize}
\end{itemize}



%Parametros não inicializadas
%	Metricas: UAV
%
%	*Essa métrica identifica parametros de funções que sao passados sem serem inicializados.
%
%

%Operações lógicas (somas, divisoes) com integridade ameaçada
%	Metricas: dbz rogu


\subsubsection{Operações lógicas (somas, divisoes) com integridade ameaçada}
%-------------------------------------------------------------------------------

Este cenário busca identificar no código fonte ocorrência de operações lógicas que podem estar comprometidas por utilizarem variaveis indefinidas ou não inicializadas, compromentendo então a integridade da operação.

Dessa forma, o software pode ter um comportamento diferente do esperado, pois o resultado da operação é indefinido, podendo levar o fluxo da aplicação para outro rumo ou fornecendo resultados errados ao usuário.

Em termos de métricas, as métricas DBZ (\emph{Division by zero}) e ROGU (\emph{Result of operation is garbage or Undefined}) buscam identificar ocorrências desse cenário no código fonte. 

As divisões por zero, na linguagem C/C++, podem causar falha na aplicação, afetando sua disponibilidade. Esta vulnerabilidade é até definida pela CWE 396 \footnote{http://cwe.mitre.org/data/definitions/369.html}. Sugere-se verificar se o divisor é zero antes de se realizar a operação.

A métrica ROGU busca identificar operações em que o resultado pode ser lixo ou indefinido. Por exemplo, se utilizamos uma variável não inicializada em uma equação, o resultado fica indefinido, pois certamente essa variável não inicializada terá lixo de memória em seu conteúdo. Essa métrica busca identificar esse tipo de situação. Como solução, sugere-se então inicializar as variáveis que irão participar da operação, garantindo assim que haverá o mínimo de integridade para a operação.

 Quadro resumo:

\begin{itemize}
\item \textbf{Nome}: \emph{Operações lógicas (somas, divisoes) com integridade ameaçada}
\item \textbf{Classificação}: Composta;
\item \textbf{Métricas Envolvidas}: DBZ (\emph{Division by zero}) e ROGU (\emph{Result of operation is garbage or Undefined}) 
\item \textbf{Nível}: Arquivo;
\item \textbf{Descrição}: Este cenário busca identificar no código fonte ocorrência de operações lógicas que podem estar comprometidas por utilizarem variáveis indefinidas ou não inicializadas, comprometendo então a integridade da operação.
\item \textbf{Caracterização com Métricas}: DBZ + ROGU >=1
	\begin{itemize}
	\item Este cenário ocorre quando é encontrado pelo menos uma ocorrência de uma dessas vulnerabilidades.
	\end{itemize}
\item \textbf{Ações sugeridas}: 
	\begin{itemize}
	\item \textbf{Verificar divisor antes da operação} - Verificar se o divisor é zero antes de realizar a operação;  
	\item \textbf{Inicializar variáveis antes de operações} - Garantir que todas as variáveis estão pelo menos pré-inicializadas antes de participarem de uma operação 
	 
	\end{itemize}
\end{itemize}

%TODO: fazer um comentário geral, em especial, chamando a atenção que são proposta iniciais e que outros cenários serão pensados, e "chamar" o resumo na tabela abaixo.

A seguir, foi montado uma tabela resumo com todos o cenários propostos até o momento, a fim de sintetizar suas principais características, métricas envolvidas e ações sugeridas.


\begin{landscape}

% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[H]
\begin{center}
\begin{tabular}{|p{2,5cm}| p{3cm} | p{2cm} | p{5.5cm} | p{3.5cm}  | p{6cm}  |}
\hline
Cenário                                        & Tipo                & Nível  & Descrição                                                                                                                                                                                 & Fórmula                                    & Ações Sugeridas                                                                                                                                                                                                                                     \\ \hline
Alta Superficie de Ataque a Atributos Internos & Qualidade de código & Classe & Esse cenário busca identificar classes que possuem muita exposição devido ao alto número de atributos públicos, violando o princípio de design seguro Redução de Superfície de Ataque     & NPA/NOA \textgreater 0.2                   & Refatorações aplicáveis: Encapsulate Field; Princípios: Princípio e Redução de Superfície de Ataque; Princípio de Encapsulamento;                                                                                                                   \\ \hline
Alta Superfície de Ataque Operacional          & Qualidade de código & Classe & Esse cenário busca identificar classes que devem receber maior atenção em relação à aplicação do princípio Mediate Completely devido à grande exposição da classe em termos operacionais. & NPM \textgreater 10 || ANPM \textgreater 3 & Refatorações: Hide Method; Remove Parameter;Princípios: Princípio e Redução de Superfície de Ataque; Princípio de Encapsulamento; Princípios de Distribuição de Responsabilidades GRASP; Padrões: Facade;\\ \hline
Ponto Crítico de Falha                         & Qualidade de código & Classe & Esse cenário busca identificar classes que potencialmente são pontos críticos do projeto de software.                                                                                     & ACC + NOC \textgreater 5                   & Refatorações: Extract Class; Move Method; Push Down Method;Princípios: Modularização, Baixo Acoplamento; Princípio de Encapsulamento; Princípios de Distribuição de Responsabilidades GRASP                                                         \\ \hline
\end{tabular}
\caption{Parte I - Resumo de todos os cenários}
		    \label{tab:resumo1}
\end{center}
\end{table}



	\begin{table}[H]
		\begin{center}
	    \begin{tabular}{ |p{2,5cm}| p{3cm} | p{2cm} | p{5cm} | p{3.5cm}  | p{6.5cm}  |}
	    \hline
Cenário                                              & Tipo                       & Nível   & Descrição                                                                                                                                                       & Fórmula                                     & Ações Sugeridas                                                                                                                                                                                                                                                      \\ \hline
Risco Elevado de Segurança                           & Qualidade de código        & Classe  & Esse cenário busca identificar métodos que aumentam o risco de problemas de segurança e bugs no código-fonte devido sua complexidade e difícil manutenção.      & ACCM \textgreater 4 || MLOC \textgreater 10 & Refatorações aplicáveis: Extract Method, Extract Surrounding Method, Replace Conditional with Polymorphism, Replace Nested Conditional with Guard Clauses , Substitute Algorithm; Princípios:Princípio de Economia de Mecanismos; Princípio da Simplicidade ou KISS; \\ \hline
Uso de variáveis não inicializadasl                  & Vulnerabilidade específica & Arquivo & Este cenário busca identificar o uso de variáveis não inicializadas, pois isso pode causar desde falhas na aplicação quanto acesso a informação não autorizado. & AUV + UAV + ROGU \textgreater= 1            & Refatorações: Criar mecanismos para garantir que a variável será inicializada antes de ser usada; Princípios: Fail Securery                                                                                                                                          \\ \hline
Alta possibilidade de Falha por mau uso de ponteiros & Vulnerabilidade específica & Arquivo & Este cenário busca identificar o uso de ponteiros de maneira não segura, que podem gerar falha na aplicação.                                                    & NP + DF + AUF + DUPV + BD \textgreater=1    & Refatorações: Extract Class; Move Method; Push Down Method;Princípios: Modularização, Baixo Acoplamento; Princípio de Encapsulamento; Princípios de Distribuição de Responsabilidades GRASP                                                                          \\ \hline
\end{tabular}
		    \caption{Parte II - Resumo de todos os cenários}
		    \label{tab:resumo2}
		\end{center}
	\end{table}

	\begin{table}[H]
		\begin{center}
	    \begin{tabular}{ |p{2,5cm}| p{3cm} | p{2cm} | p{5cm} | p{3.5cm}  | p{6.5cm}  |}
	    \hline
Cenário                                                      & Tipo                       & Nível   & Descrição                                                                                                                                                                                                                                                                          & Fórmula                    & Ações Sugeridas                                                                                                                                                                                         \\ \hline
Buffer Overflow                                              & Vulnerabilidade específica & Arquivo & Este cenário busca identificar situações no código fonte que podem gerar a vulnerabilidade de Buffer Overflow (Estouro de memória);                                                                                                                                                & ASOM + FGBO \textgreater=1 & Refatorações: Substituir chamadas para a função "gets" ; Fazer match dos operadores de alocação de memória;                                                                                             \\ \hline
Confidencia-lidade Ameaçada                                   & Vulnerabilidade específica & Arquivo & Este cenário busca identificar trechos de código fonte que podem fornecer informações não autorizadas, impactando na confidencialidade do sistema.  & OBAA + DUPV \textgreater=1 & Refatorações: Especificar e verificar o range o array antes de acessa-lo; Garantir que o ponteiro não seja indefinido antes de desreferencia-lo                                                         \\ \hline
Operações lógicas (somas, divisoes) com integridade ameaçada & Vulnerabilidade específica & Arquivo & Este cenário busca identificar no código fonte ocorrência de operações lógicas que podem estar comprometidas por utilizarem variáveis indefinidas ou não inicializadas, comprometendo então a integridade da operação.                                                             & DBZ + ROGU \textgreater=1  & Para cada métrica, deve se tomar uma ação específica para resolve-la. Então, caso ocorra este cenário, devemos observar qual das vulnerabilidades ocorreu trabalhar para reduzir o valor dessa métrica. \\ \hline
\end{tabular}
		    \caption{Parte III - Resumo de todos os cenários}
		    \label{tab:resumo3}
		\end{center}
	\end{table}


\end{landscape}

